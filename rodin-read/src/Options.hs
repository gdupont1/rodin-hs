{-|
Module      : Options
Description : a module for processing transformation configuration
Copyright   : (c) Guillaume Dupont, 2021
License     : GPLv3
Maintainer  : guillaume.dupont55@gmail.com

This is an utility "companion" module for handling transformation
options. It regroups the parsing, substitution and writing operations
using typeclasses and generic functions.
-}
module Options where

import Control.Monad
import Data.List.Split (splitOn)
import Data.List (intercalate,union)

import Rodin.TeX
import Rodin.Ascii
import Rodin.Substitution
import Rodin.Theory (Theory)
import Rodin.Theory.Read
import Rodin.Theory.TeX
import Rodin.Theory.Ascii
import Rodin.Theory.Substitution
import Rodin.Context (Context)
import Rodin.Context.Read
import Rodin.Context.TeX
import Rodin.Context.Ascii
import Rodin.Context.Substitution
import Rodin.Machine (Machine)
import Rodin.Machine.Read
import Rodin.Machine.TeX
import Rodin.Machine.Ascii
import Rodin.Machine.Substitution
import Rodin.ProofObligations (POFile)
import Rodin.ProofObligations.Read
import Rodin.ProofObligations.TeX
import Rodin.ProofObligations.Ascii
import Rodin.ProofObligations.Substitution

-- | Define a type as being "parsable"
-- This serves as a wrapper for defining parser configurations.
-- To properly add a parser, one should first create a new constructor in the Parsed data type,
-- then instanciate the resulting structure of its parser as being parsable.
class Parsable a where
  toParsed :: a -> Parsed

-- | A Context is parsable
instance Parsable Context where
  toParsed = PContext

-- | A Machine is parsable
instance Parsable Machine where
  toParsed = PMachine

-- | A Theory is parsable
instance Parsable Theory where
  toParsed = PTheory

-- | Proof Obligation file is parsable
instance Parsable POFile where
  toParsed = PPOFile

-- | Parsed data type, effectively wrapping the structures resulting from parsing.
-- When adding a parser, one should also add a constructor to this type that wraps her new structure.
data Parsed =
      PContext Context
    | PMachine Machine
    | PTheory  Theory
    | PPOFile  POFile

-- | Parsed can be ShowTeX; it comes from the fact that the objects in its constructors are effectively ShowTeX
-- If one want to be able to export its parsed structure to TeX, it should add the relevant line
instance ShowTeX Parsed where
  showTeX (PContext ct) = showTeX ct
  showTeX (PMachine ma) = showTeX ma
  showTeX (PTheory  th) = showTeX th
  showTeX (PPOFile  po) = showTeX po

-- | Same thing as for ShowTeX but for ASCII
instance ShowAscii Parsed where
  showAscii (PContext ct) = showAscii ct
  showAscii (PMachine ma) = showAscii ma
  showAscii (PTheory  th) = showAscii th
  showAscii (PPOFile  po) = showAscii po

-- | Similar mechanism for Substituable
instance Substituable Parsed where
  substitute st (PContext ct) = PContext $ substitute st ct
  substitute st (PMachine ma) = PMachine $ substitute st ma
  substitute st (PTheory  th) = PTheory  $ substitute st th
  substitute st (PPOFile  po) = PPOFile  $ substitute st po

-- | Create a parser for a parsable object based on its actual parser.
-- This will basically take any parser of the form String -> IO a to a parser of the form String -> IO Parsed (effectively doing the wrapping).
mkParser :: Parsable a => (String -> IO (Maybe a)) -> (String -> IO (Maybe Parsed))
mkParser parser =
    \x -> parser x >>= (return . (fmap toParsed))

-- | A read (or parsing) configuration.
data ReadConfig = ReadConfig {
    readerName :: String,                       -- ^ Name of the parser (for pretty printing)
    processor  :: String -> IO (Maybe Parsed)   -- ^ The parsing function
}

-- | List of possible reading configurations as a (<file extension>,<reading configuration>) list
-- When adding a new parser, one should extend this table with correct informations.
readConfTable :: [(String,ReadConfig)]
readConfTable =
    [ ("buc",ReadConfig "context"           $ mkParser parseContextFile)
    , ("bum",ReadConfig "machine"           $ mkParser parseMachineFile)
    , ("tuf",ReadConfig "theory"            $ mkParser parseTheoryFile )
    , ("bpo",ReadConfig "proof obligations" $ mkParser parsePOFileFile) ]

-- | A write configuration
data WriteConfig = WriteConfig {
    writerName :: String,           -- ^ Writer name (for pretty printing)
    writerExtension :: String,      -- ^ File extension for the files generated by the writer
    stringify :: Parsed -> String   -- ^ Function turning a Parsed object to a proper string
}

-- | Retrieve file base name (i.e. without prefix path)
basename :: String -> String
basename = last . (splitOn "/")

-- | Change the directory of a file
setDir :: String -> String -> String
setDir "" s = s
setDir od s = od ++ (if last od == '/' then "" else "/") ++ (basename s)

-- | Write a content to a file at the given directory.
writeOut :: WriteConfig -> String -> String -> Parsed -> IO ()
writeOut conf filename outdir parsed =
    writeFile newfile $ stringify conf parsed
    where newfile = (setDir outdir filename) ++ "." ++ writerExtension conf



-- | List of possible writing configurations as a (<file extension>,<writing configuration>) list
-- If one wants to add a new writer, it should create a typeclass for it and instanciate it for the various parsed structures.
-- It should then instanciate it for the Parsed type and add it to this table.
writeConfTable :: [(String,WriteConfig)]
writeConfTable = 
    [ (  "tex",WriteConfig "TeX"   "tex"   (showTeX))
    , ("ascii",WriteConfig "ASCII" "ascii" (showAscii)) ]

-- | Default writing configuration (TeX)
defaultWriteConfig :: WriteConfig
defaultWriteConfig = WriteConfig "TeX" "tex" showTeX

-- | Read substitutions of command line
readSubstitutions :: [String] -> IO Rules
readSubstitutions substs = do
    st  <- foldM unionSubst [] substs
    putStrLn "Checking for incoherence..."
    detectcollisions st
    putStrLn "Compiling..."
    st' <- compile st
    putStrLn "Substitution processing done!"
    putStrLn $ "=> " ++ (show $ length st') ++ " rules processed"
    return st'
    where unionSubst :: Rules -> String -> IO Rules
          unionSubst acc fn = do
              putStrLn $ "Processing " ++ fn ++ "..."
              (n, rls) <- fromFile fn
              if n > 0
                  then do
                      putStrLn $ "=> There were errors while processing " ++ fn ++ ". File has been ignored"
                      return acc
                  else do
                      putStrLn $ "=> Done; " ++ (show $ length rls) ++ " rules extracted."
                      return (union acc rls)
          detectcollisions :: Rules -> IO ()
          detectcollisions st = do
              let cs = collisions st in
                  if not $ null cs
                      then putStrLn $ "Warning: collisions found in merged substitution table!\n" ++ showCollisions cs
                      else return ()
          showCollisions collisions =
              foldl showCollision [] $ zip [1..] collisions
          showCollision acc (i,rules) =
              acc ++ ("\nCollision " ++ show i ++":") ++ (foldl showRule [] rules)
          showRule acc r =
              acc ++ "\n - " ++ show r

-- | Type for result of the command line reading
data Option =
      Error [String]  -- ^ Command line is inconsistent and raised an error
    | Help            -- ^ Command line asks for help
    | Cmd Command     -- ^ Command line parses to some options
    | NoOption        -- ^ Nothing on the command line

-- | Structure for holding the command line arguments
data Command = Command {
    writeconf :: WriteConfig,              -- ^ Writing configuration (e.g. TeX, ASCII)
    readconfs :: [(String,ReadConfig)],    -- ^ Reading configuration as a pair of file-readconfig
    outputdir :: String,                   -- ^ Output directory
    substitutionFiles :: [String]          -- ^ List of substitution files
}

-- | Default command for building actual commands upon
defaultCommand :: Command
defaultCommand = Command defaultWriteConfig [] "" []

-- | Kind of monadic following (>>) for options (easier to read)
infixl 1 `cue`
cue :: Option -> Option -> Option
cue NoOption x = x
cue x NoOption = x
cue Help _ = Help
cue _ Help = Help
cue (Error e1) (Error e2) = Error $ e2 ++ e1
cue e@(Error _) _ = e
cue _ e@(Error _) = e
cue (Cmd c1) c@(Cmd c2) = c

-- | Kind of monadic composition (>>=) for options (easier to read)
infixl 1 `chain`
chain :: Option -> (Command -> Option) -> Option
chain NoOption f = f defaultCommand
chain Help _ = Help
chain e@(Error _) _ = e
chain (Cmd c1) f = f c1

-- | Read the argument options and return either a Nothing if there is
-- nothing to do or a writing configuration + a set of reading configurations
-- associated with file names.
readopt :: [String] -> Option
readopt [] = NoOption
readopt ("-h":xs) = Help
readopt ("-d":[]) = 
    Error $ ["Error: expected string after -d option."]
readopt ("-d":x:xs)
    | head x == '-' = readopt (x:xs) `cue` readopt ["-d"]
    | otherwise =
        readopt xs `chain` \cmd ->
            Cmd $ cmd { outputdir = x }
readopt ("-s":[]) = 
    Error $ ["Error: expected string after -s option."]
readopt ("-s":x:xs)
    | head x == '-' = readopt (x:xs) `cue` readopt ["-s"]
    | otherwise =
        readopt xs `chain` \cmd ->
            Cmd $ cmd { substitutionFiles = (substitutionFiles cmd) ++ [x] }
readopt (x:xs) =
    readopt xs `chain` \cmd ->
        if head x == '-' then
            case lookup (tail x) writeConfTable of
              Nothing -> Error ["Unknown writing configuration '" ++ x ++ "'"]
              Just wc' -> Cmd $ cmd { writeconf = wc' }
        else
            case lookup (ext x) readConfTable of
              Nothing -> Error ["Cannot find parser for file '" ++ x ++ "'"]
              Just rc -> Cmd $ cmd { readconfs = (x,rc):(readconfs cmd) }
    where ext = last . splitOn "."








